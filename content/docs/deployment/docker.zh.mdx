---
title: Docker 部署
description: 使用 Docker 容器部署 AIGXT
icon: "Container"
---

# Docker 部署

本指南涵盖使用 Docker 容器部署 AIGXT，适用于容器化部署场景。

## 前置要求

在使用 Docker 部署之前，请确保您有：

- 系统上安装了 Docker
- Docker Compose（可选，用于多容器设置）
- 准备好部署的 AIGXT 项目
- 数据库可从容器访问

## Docker 设置

### Dockerfile

项目包含用于容器化的 `Dockerfile`：

```dockerfile
FROM node:18-alpine AS base

# 仅在需要时安装依赖项
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

# 根据首选的包管理器安装依赖项
COPY package.json pnpm-lock.yaml* ./
RUN corepack enable pnpm && pnpm i --frozen-lockfile

# 仅在需要时重建源代码
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# 构建应用程序
RUN corepack enable pnpm && pnpm build

# 生产镜像，复制所有文件并运行 next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# 为预渲染缓存设置正确的权限
RUN mkdir .next
RUN chown nextjs:nodejs .next

# 自动利用输出跟踪来减少镜像大小
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

### Docker Compose

创建 `docker-compose.yml` 用于多容器部署：

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:password@db:5432/aigxt
      - NEXTAUTH_SECRET=your-secret-key
      - NEXTAUTH_URL=http://localhost:3000
      - OPENAI_API_KEY=your-openai-key
      - REPLICATE_API_TOKEN=your-replicate-token
    depends_on:
      - db
    volumes:
      - ./uploads:/app/uploads
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=aigxt
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

## 构建和运行

### 构建 Docker 镜像

```bash
# 构建 Docker 镜像
docker build -t aigxt:latest .

# 或使用 Docker Compose
docker-compose build
```

### 运行容器

```bash
# 运行单个容器
docker run -p 3000:3000 \
  -e DATABASE_URL="postgresql://user:pass@host:5432/db" \
  -e NEXTAUTH_SECRET="your-secret" \
  -e OPENAI_API_KEY="your-key" \
  aigxt:latest

# 或使用 Docker Compose
docker-compose up -d
```

### 环境变量

创建 `.env.docker` 文件用于 Docker 特定的环境变量：

```bash
# 数据库
DATABASE_URL="postgresql://postgres:password@db:5432/aigxt"

# 身份验证
NEXTAUTH_SECRET="your-production-secret-key"
NEXTAUTH_URL="http://localhost:3000"

# AI 服务
OPENAI_API_KEY="sk-your-openai-api-key"
REPLICATE_API_TOKEN="r8_your-replicate-token"
DEEPSEEK_API_KEY="your-deepseek-api-key"

# Stripe
STRIPE_PUBLISHABLE_KEY="pk_live_your-publishable-key"
STRIPE_SECRET_KEY="sk_live_your-secret-key"
STRIPE_WEBHOOK_SECRET="whsec_your-webhook-secret"

# 文件存储
AWS_ACCESS_KEY_ID="your-access-key"
AWS_SECRET_ACCESS_KEY="your-secret-key"
AWS_REGION="us-east-1"
AWS_S3_BUCKET="your-bucket-name"

# Redis（如果使用）
REDIS_URL="redis://redis:6379"
```

## 生产部署

### 多阶段构建优化

Dockerfile 使用多阶段构建进行优化：

```dockerfile
# 阶段 1：依赖项
FROM node:18-alpine AS deps
WORKDIR /app
COPY package.json pnpm-lock.yaml* ./
RUN corepack enable pnpm && pnpm i --frozen-lockfile

# 阶段 2：构建器
FROM node:18-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN corepack enable pnpm && pnpm build

# 阶段 3：运行器
FROM node:18-alpine AS runner
WORKDIR /app
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY --from=builder /app/public ./public
EXPOSE 3000
CMD ["node", "server.js"]
```

### 生产 Docker Compose

```yaml
version: '3.8'

services:
  app:
    build: 
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    env_file:
      - .env.docker
    depends_on:
      - db
      - redis
    volumes:
      - app_uploads:/app/uploads
      - app_logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=aigxt
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 10s
      retries: 3

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  app_uploads:
  app_logs:
```

## Nginx 配置

### 反向代理设置

创建 `nginx.conf` 用于反向代理：

```nginx
events {
    worker_connections 1024;
}

http {
    upstream app {
        server app:3000;
    }

    server {
        listen 80;
        server_name your-domain.com;

        # 将 HTTP 重定向到 HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name your-domain.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        # 安全头
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;

        # Gzip 压缩
        gzip on;
        gzip_vary on;
        gzip_min_length 1024;
        gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;

        location / {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # 静态文件
        location /_next/static {
            proxy_pass http://app;
            proxy_cache_valid 200 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}
```

## 数据库迁移

### 迁移脚本

为 Docker 部署创建迁移脚本：

```bash
#!/bin/bash
# migrate.sh

echo "等待数据库准备就绪..."
until pg_isready -h db -p 5432 -U postgres; do
  echo "数据库不可用 - 等待中"
  sleep 1
done

echo "数据库已准备就绪 - 运行迁移"
cd /app
pnpm db:migrate

echo "迁移完成"
```

### 带迁移的 Docker Compose

```yaml
services:
  migrate:
    build: .
    command: sh -c "sleep 10 && pnpm db:migrate"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/aigxt
    depends_on:
      - db
    restart: "no"
```

## 健康检查

### 应用程序健康检查

创建健康检查端点：

```typescript
// src/app/api/health/route.ts
import { NextResponse } from 'next/server';
import { db } from '@/db';

export async function GET() {
  try {
    // 检查数据库连接
    await db.execute('SELECT 1');
    
    return NextResponse.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: {
        database: 'connected',
        application: 'running',
      },
    });
  } catch (error) {
    return NextResponse.json(
      {
        status: 'unhealthy',
        timestamp: new Date().toISOString(),
        error: error instanceof Error ? error.message : '未知错误',
      },
      { status: 500 }
    );
  }
}
```

### Docker 健康检查

```dockerfile
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/api/health || exit 1
```

## 监控和日志

### 日志配置

```typescript
// src/lib/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: '/app/logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: '/app/logs/combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

export default logger;
```

### Docker 日志

```yaml
services:
  app:
    # ... 其他配置
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

## 安全考虑

### Docker 安全

```dockerfile
# 使用非 root 用户
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
USER nextjs

# 删除不必要的包
RUN apk del build-dependencies

# 使用特定版本
FROM node:18-alpine@sha256:...
```

### 环境安全

```bash
# 对敏感数据使用 Docker secrets
echo "your-secret-key" | docker secret create nextauth_secret -
echo "your-db-password" | docker secret create db_password -
```

```yaml
services:
  app:
    secrets:
      - nextauth_secret
      - db_password
    environment:
      - NEXTAUTH_SECRET_FILE=/run/secrets/nextauth_secret
      - DB_PASSWORD_FILE=/run/secrets/db_password

secrets:
  nextauth_secret:
    external: true
  db_password:
    external: true
```

## 扩展

### 水平扩展

```yaml
services:
  app:
    # ... 其他配置
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
```

### 负载均衡器

```yaml
services:
  nginx:
    # ... 其他配置
    volumes:
      - ./nginx-lb.conf:/etc/nginx/nginx.conf

  app1:
    build: .
    environment:
      - INSTANCE_ID=1

  app2:
    build: .
    environment:
      - INSTANCE_ID=2

  app3:
    build: .
    environment:
      - INSTANCE_ID=3
```

## 备份和恢复

### 数据库备份

```bash
#!/bin/bash
# backup.sh

BACKUP_DIR="/app/backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/aigxt_backup_$DATE.sql"

mkdir -p $BACKUP_DIR

pg_dump -h db -U postgres aigxt > $BACKUP_FILE

# 只保留最近 7 天的备份
find $BACKUP_DIR -name "*.sql" -mtime +7 -delete

echo "备份完成: $BACKUP_FILE"
```

### 自动备份

```yaml
services:
  backup:
    image: postgres:15-alpine
    volumes:
      - ./backups:/backups
      - ./backup.sh:/backup.sh
    environment:
      - PGPASSWORD=password
    command: sh -c "chmod +x /backup.sh && crontab -l | { cat; echo '0 2 * * * /backup.sh'; } | crontab - && crond -f"
    depends_on:
      - db
```

## 故障排除

### 常见问题

#### 容器无法启动

```bash
# 检查容器日志
docker logs <container-id>

# 检查端口是否已被使用
netstat -tulpn | grep :3000
```

#### 数据库连接问题

```bash
# 测试数据库连接
docker exec -it <container-id> pg_isready -h db -p 5432

# 检查数据库日志
docker logs <db-container-id>
```

#### 性能问题

```bash
# 监控资源使用情况
docker stats

# 检查容器健康状态
docker inspect <container-id> | grep Health
```

### 调试

#### 交互式 Shell

```bash
# 访问正在运行的容器
docker exec -it <container-id> sh

# 运行新容器进行调试
docker run -it --rm aigxt:latest sh
```

#### 日志分析

```bash
# 实时跟踪日志
docker-compose logs -f app

# 按服务过滤日志
docker-compose logs app | grep ERROR
```

## 最佳实践

1. **多阶段构建**：使用多阶段构建获得更小的镜像
2. **非 root 用户**：以非 root 用户运行容器
3. **健康检查**：为所有服务实施健康检查
4. **资源限制**：设置适当的资源限制
5. **密钥管理**：对敏感数据使用 Docker secrets
6. **日志记录**：实施结构化日志记录
7. **备份**：定期数据库备份
8. **监控**：设置监控和警报
9. **安全**：保持基础镜像更新
10. **文档**：记录所有配置更改

## 生产检查清单

- [ ] Docker 镜像已构建和测试
- [ ] 环境变量已配置
- [ ] 数据库迁移已应用
- [ ] 健康检查已实施
- [ ] 日志记录已配置
- [ ] 监控已设置
- [ ] 备份策略已就位
- [ ] 安全措施已实施
- [ ] 负载均衡器已配置
- [ ] SSL 证书已安装

您的 AIGXT 应用程序现在已准备好进行 Docker 部署！🐳
